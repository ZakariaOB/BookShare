Working skeleton API
----------------------------------------

- Useful commands to work for .NET projects
  => dotnet --version : All the installed versions on the machine
  => dotnet -h : help commands
  => dotnet new sln : solution file

- dotnet new webapi -o API : -o output directory as we need the api to have it's own folder
- Add the api to our solution : dotnet sln add API
- In VS code : to hide some folders or files from the solution you can use Files:exclude
  add pattern example : **/bin ; **/obj
- Command to run the .Net core project : dotent run
- Security : Some websites are using https in order to secure the data exchanged using SSL and more adapted version
  TLS => https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https
- Https : https://stackoverflow.com/questions/8375134/difference-between-http-and-https#:~:text=HTTPS%20means%20that%20you%20tunnel,How%20to%20use%20HTTPS%3F
- In order for my machine to trust the .NET certificate
  dotnet dev-certs https --trust
- Review : Lecture 8
- dotnet run => Run the application
- The entry point for our application is Program.cs
- Logging level : What happend when we hit endpoints is described by the console logging system
- Use Https redirection (UseHttpsRedirection) : If we come with an http url we are redirected to an https one 
- "launchBrowser": false in launchSettings.json
- dotnet watch run => Keep an eye on the changes
- Benefits of EF :
    => Querying
    => Change tracking
    => Saving
    => Concurrency
    => Transactions
    => Caching
    => Built-in-conventions (Id, foreign key names etc ...)
    => Migrations
- Install Nuget gallery for nuget management
- In order to use the DbContext inside the app make sure to inject it also inside StartUp.cs class
- We can use on appSettings.Developpemnt.json any information that could be seen bu other users
- In order to start code first with EF we need to install dotnet-ef . But it's already installed with EFSql server
  - Migration command : dotnet ef migrations add initialCreate -o Data/Migrations
  > -o : create a folder
- Dotnet tool EF update 
    (update : Update | install : Install)
  => dotnet tool update --global dotnet-ef --version 5.0.0-preview.8.20407.4
- The migration files are used to run against a database , when you create a migration it's not updating the model.
- To undo the migration action, use 'ef migrations remove'
- dotnet ef database update
- Always use asynchronous code when dealing with database calls
- Init a git repo : git init
- Add git ignore file : dotnet new gitignore
- appsettings.json should be ignored : To recheck later
- To link the local repo to a distant one : git remote add origin https://github.com/ZakariaOB/BookShare.git


Working skeleton ANGULAR
----------------------------------------
- update 
    NodeJs : Reinstall it
    npm : 
       Run PowerShell as Administrator
        Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Force
        npm install -g npm-windows-upgrade
        npm-windows-upgrade   
- Use the angular CLI
- npm install -g @angular/cli
- Decoratcor : Giving a class some extra power
- Lecture : 23 => Making http requests in Angular

- CORS : Modern browsers will not allow reaching an app from a different origin than 
  the one containing it (The difference could be simply on the port number, as example API and client
  projects that we are using) . To allow this AddCors() inside the API.
- Normally don't use jQuery as Angular also change the DOM
- Install angular bootstrap (ngx-bootstrap)
- ng add ngx-bootstrap
- Install a certificate for our angular app to use https (SSL)
- We don't want to put any sensible information inside our client project


Authentication basics
-----------------------------------------------
- dotnet ef migrations add UpdateAppUser -o Data/Migrations
- Think about validating your dtos coming from the client side even if the client will validate 
  things before hitting the API
- [APIController] is the responsible of using DTOs validation rules and send back issues 
  for the requests coming from the API .
- We can validate our models : [Required] , [Email], [StringLength] and others and we can also 
  our custom validators
- Did the register endpoint and then the login one inside the AccountController
- Services are good to manage on 'AddScoped' as we don't need the service as soon as a request 
  is done .
- For new packages => Open nuGet gallery
- In order for .NET core to handle the authentication we need Microsoft.AspNetCore.Authentication.JwtBearer
  installed .
- The logic behind is that : We use the authentication middlware of .NET core and we configure it on the StartUp class 
  > services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) (Extension class)
  > app.UseAuthentication => to enbale the usage of the service 
  > app.UseAuthorization => To enable the usage of the UseAuthorization
  > At this point when you login you get your token generated inside the app and propably recognized by the authentication middlware
  > Now the app knwos your token
  > [Authorize] will check your token and will give you access or not to the requested action



Client login and register :
----------------------------------------
- ng g c nav --skip-tests (Create a component withour tests)
- to add a form => #loginForm="ngForm"
- ng g c home --skip-tests
- ng g c register --skip-tests

Routing in Angular
---------------------------------------------
- npm install bootswatch => Bootstrap themes
- npm install ngx-toastr => Notifications
- Adding and AuthGuard to secure routes
- Check the usage of modules in Angular

Error handling
---------------------------------------------
- To use an interceptor : 
  app.module.ts
  providers: [
    {provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true}
  ],

- Http errors
   > 404 : Not found
   > 400 : Bad request (Can be returned with BadRequest) | Validation error (The api could handle that directly or implicitly as used 
           for the model validation errors .)
   > 500 : server error should be converted by the middleware for a better usage .
   > 401: Unauthorized

- Things are not so obvious when using a middleware . The idea is to create the middleware 
  and inside it you can catch an exception . what will happen after that is by writing :
   context.Response.ContentType = "application/json";
   context.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
  An http response object will be created containg signficant information with an error object
  => HttpResponse {error = null, name, url, status, statusText} ...
  => This object can be filled from the API by using : await context.Response.WriteAsync(json);
      
      HttpErrorResponse {headers: HttpHeaders, status: 400, statusText: "OK", url: "https://localhost:5001/api/account/register", ok: false, …}
          error: {type: "https://tools.ietf.org/html/rfc7231#section-6.5.1", title: "One or more validation errors occurred.", status: 400, traceId: "00-a144dc7b92c6bb4bbe20cffc19c86b1f-802ed0763d7e2c4a-00", errors: {…}}
          headers: HttpHeaders {normalizedNames: Map(0), lazyUpdate: null, lazyInit: ƒ}
          message: "Http failure response for https://localhost:5001/api/account/register: 400 OK"
          name: "HttpErrorResponse"
          ok: false
          status: 400
          statusText: "OK"
          url: "https://localhost:5001/api/account/register"
          __proto__: HttpResponseBase

  => The idea here is to provide a json object as the error and reuse it in the client side 
     (ApiException class that was serialized to json)
  => IF the error is a 400 validation error .NET will create an HttpResponseError object with the error object filled with 
     validation error details (The middlware treatement of the issue will not be reached as no exception is raised)
          errors:
          Password: ["The Password field is required."]
          Username: ["The Username field is required."]
          __proto__: Object
          status: 400
          title: "One or more validation errors occurred."
          traceId: "00-a144dc7b92c6bb4bbe20cffc19c86b1f-802ed0763d7e2c4a-00"
          type: "https://tools.ietf.org/html/rfc7231#section-6.5.1"
          __proto__: Object

Extending the API
---------------------------------------------
- Check the usage of the ProjectTo (Automapper IQueryable exetensions) inside a BaseRepository .
- The idea I think of these projection is to send a limited select of columns to the DB .
- dotnet ef migrations add ExtendModelAddPhotos -o Data/Migrations
- Review this section and try to summarize it .
- Seed method and usage of Automapper
- When we use project to we don't need includes (Some how obvious as automapper 
  will call the DB on lazy loading mode)

Building the user interface
---------------------------------------------
- npm i @kolkov/ngx-gallery
- The best part about this section is the interceptor that will get the request before sending it
  add to it the necessary the token coming from the current user saved inside the accountService 
  and then make sure that all requests will continue to the server with out beautiful token !!! => SO NICE


Updating resources
---------------------------------------------

- In order to use ngx-spinner we will need angular-cdk
- Nice trick for the loading spinners : Using interceptors on the request pipeline
  to show / hide the loading logo => GREAT
- Always there a guard for a certain component to prevent leaving without saving 
- ViewChild => It provides a reference to elements or components in your view .
- HostListener is used to detect any change on the app outside of the angular App (Similar to ref in Vue I beleive)
- Review the usage of HostListener
- Services are singletons
- Some caching is implemented inside the memmber-list component

Photos functionnality
-----------------------------------------------------
- Don't forget : You can always strong type your config variables by creating some
  custom classes .
- The photo service will deal with cloudinary for you
- Review module and summarize 

Reactive forms
-----------------------------------------------------
- Forms on angular can have all the utilities to manage : errors object that react 
  with what's wrong .
- All Form controls derive from ngControl
- constructor(@Self() public ngControl: NgControl)
  => To access the ngControl inside the created new component
- Use use the form builder service => Reactive form

Pagination, Filtering and sorting
---------------------------------------------------------
- Filters in ASP.NET Core allow code to be run before or after specific stages in the request processing pipeline.
- LogUserActivity => Filter used to log the activity after finishing every request (Proposably at the end of the request pipeline)
- Check why the pagination information is on the header of the requests

Likes functionnality
---------------------------------------------------
- dotnet ef migrations add LikesFunctionnality -o Data/Migrations

Messages functionnality
----------------------------------------
- Route resolvers : check the usage 
- MemberDetailedResolver => this will help us to get the memeber before 
  entering the detail component .
- dotnet ef migrations add MessagingFunctionnality -o Data/Migrations


Identity
----------------------------------------
- Identity<int> has already some predefined props , hence the deletion of some props when deriving from 
  Identity<User>
- To be able to use Identity with roles we have to derive the DbContext from : 
        IdentityDbContext<AppUser, AppRole, int, IdentityUserClaim<int>, AppUserRole, IdentityUserLogin<int>, 
        IdentityRoleClaim<int>, IdentityUserToken<int>>
- Join tables in general are done using the config files
- Create the table AppRole : IdentityRole<int>
- Password hash and salt will be managed by Identity
- Managing the user will be done using the UserManager , also authorizing the user 
  and the signing will be done by the SignInManager .
- We will add the roles to the Token description : Check TokenService
- Good to note : The CurrentUser is always stored inside 
  the accountService as an Observable : currentUser$
- atob stands for ASCII to binary e.g.: atob("ZXhhbXBsZSELCg==") == "example!^K" ?? 
- dotnet ef migrations add identityMigration -o Data/Migrations
Working skeleton API
----------------------------------------

- Useful commands to work for .NET projects
  => dotnet --version : All the installed versions on the machine
  => dotnet -h : help commands
  => dotnet new sln : solution file

- dotnet new webapi -o API : -o output directory as we need the api to have it's own folder
- Add the api to our solution : dotnet sln add API
- In VS code : to hide some folders or files from the solution you can use Files:exclude
  add pattern example : **/bin ; **/obj
- Command to run the .Net core project : dotent run
- Security : Some websites are using https in order to secure the data exchanged using SSL and more adapted version
  TLS => https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https
- Https : https://stackoverflow.com/questions/8375134/difference-between-http-and-https#:~:text=HTTPS%20means%20that%20you%20tunnel,How%20to%20use%20HTTPS%3F
- In order for my machine to trust the .NET certificate
  dotnet dev-certs https --trust
- Review : Lecture 8
- dotnet run => Run the application
- The entry point for our application is Program.cs
- Logging level : What happend when we hit endpoints is described by the console logging system
- Use Https redirection (UseHttpsRedirection) : If we come with an http url we are redirected to an https one 
- "launchBrowser": false in launchSettings.json
- dotnet watch run => Keep an eye on the changes
- Benefits of EF :
    => Querying
    => Change tracking
    => Saving
    => Concurrency
    => Transactions
    => Caching
    => Built-in-conventions (Id, foreign key names etc ...)
    => Migrations
- Install Nuget gallery for nuget management
- In order to use the DbContext inside the app make sure to inject it also inside StartUp.cs class
- We can use on appSettings.Developpemnt.json any information that could be seen bu other users
- In order to start code first with EF we need to install dotnet-ef . But it's already installed with EFSql server
  - Migration command : dotnet ef migrations add initialCreate -o Data/Migrations
  > -o : create a folder
- Dotnet tool EF update 
    (update : Update | install : Install)
  => dotnet tool update --global dotnet-ef --version 5.0.0-preview.8.20407.4
- The migration files are used to run against a database , when you create a migration it's not updating the model.
- To undo the migration action, use 'ef migrations remove'
- dotnet ef database update
- Always use asynchronous code when dealing with database calls
- Init a git repo : git init
- Add git ignore file : dotnet new gitignore
- appsettings.json should be ignored : To recheck later
- To link the local repo to a distant one : git remote add origin https://github.com/ZakariaOB/BookShare.git


Working skeleton ANGULAR
----------------------------------------
- update 
    NodeJs : Reinstall it
    npm : 
       Run PowerShell as Administrator
        Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Force
        npm install -g npm-windows-upgrade
        npm-windows-upgrade   
- Use the angular CLI
- npm install -g @angular/cli
- Decoratcor : Giving a class some extra power
- Lecture : 23 => Making http requests in Angular

- CORS : Modern browsers will not allow reaching an app from a different origin than 
  the one containing it (The difference could be simply on the port number, as example API and client
  projects that we are using) . To allow this AddCors() inside the API.
- Normally don't use jQuery as Angular also change the DOM
- Install angular bootstrap (ngx-bootstrap)
- ng add ngx-bootstrap
- Install a certificate for our angular app to use https (SSL)
- We don't want to put any sensible information inside our client project


Authentication basics
-----------------------------------------------
- dotnet ef migrations add UpdateAppUser -o Data/Migrations
- Think about validating your dtos coming from the client side even if the client will validate 
  things before hitting the API
- [APIController] is the responsible of using DTOs validation rules and send back issues 
  for the requests coming from the API .
- We can validate our models : [Required] , [Email], [StringLength] and others and we can also 
  our custom validators
- Did the register endpoint and then the login one inside the AccountController
- Services are good to manage on 'AddScoped' as we don't need the service as soon as a request 
  is done .
- For new packages => Open nuGet gallery
- In order for .NET core to handle the authentication we need Microsoft.AspNetCore.Authentication.JwtBearer
  installed .
- The logic behind is that : We use the authentication middlware of .NET core and we configure it on the StartUp class 
  > services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) (Extension class)
  > app.UseAuthentication => to enbale the usage of the service 
  > app.UseAuthorization => To enable the usage of the UseAuthorization
  > At this point when you login you get your token generated inside the app and propably recognized by the authentication middlware
  > Now the app knwos your token
  > [Authorize] will check your token and will give you access or not to the requested action



Client login and register :
----------------------------------------
- ng g c nav --skip-tests (Create a component withour tests)
- to add a form => #loginForm="ngForm"
- ng g c home --skip-tests
- ng g c register --skip-tests

Routing in Angular
---------------------------------------------
- npm install bootswatch => Bootstrap themes
- npm install ngx-toastr => Notifications
- Adding and AuthGuard to secure routes
- Check the usage of modules in Angular

Error handling
---------------------------------------------
- To use an interceptor : 
  app.module.ts
  providers: [
    {provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true}
  ],

- Http errors
   > 404 : Not found
   > 400 : Bad request (Can be returned with BadRequest) | Validation error (The api could handle that directly or implicitly as used 
           for the model validation errors .)
   > 500 : server error should be converted by the middleware for a better usage .
   > 401: Unauthorized

- Things are not so obvious when using a middleware . The idea is to create the middleware 
  and inside it you can catch an exception . what will happen after that is by writing :
   context.Response.ContentType = "application/json";
   context.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
  An http response object will be created containg signficant information with an error object
  => HttpResponse {error = null, name, url, status, statusText} ...
  => This object can be filled from the API by using : await context.Response.WriteAsync(json);
      
      HttpErrorResponse {headers: HttpHeaders, status: 400, statusText: "OK", url: "https://localhost:5001/api/account/register", ok: false, …}
          error: {type: "https://tools.ietf.org/html/rfc7231#section-6.5.1", title: "One or more validation errors occurred.", status: 400, traceId: "00-a144dc7b92c6bb4bbe20cffc19c86b1f-802ed0763d7e2c4a-00", errors: {…}}
          headers: HttpHeaders {normalizedNames: Map(0), lazyUpdate: null, lazyInit: ƒ}
          message: "Http failure response for https://localhost:5001/api/account/register: 400 OK"
          name: "HttpErrorResponse"
          ok: false
          status: 400
          statusText: "OK"
          url: "https://localhost:5001/api/account/register"
          __proto__: HttpResponseBase

  => The idea here is to provide a json object as the error and reuse it in the client side 
     (ApiException class that was serialized to json)
  => IF the error is a 400 validation error .NET will create an HttpResponseError object with the error object filled with 
     validation error details (The middlware treatement of the issue will not be reached as no exception is raised)
          errors:
          Password: ["The Password field is required."]
          Username: ["The Username field is required."]
          __proto__: Object
          status: 400
          title: "One or more validation errors occurred."
          traceId: "00-a144dc7b92c6bb4bbe20cffc19c86b1f-802ed0763d7e2c4a-00"
          type: "https://tools.ietf.org/html/rfc7231#section-6.5.1"
          __proto__: Object

Extending the API
---------------------------------------------
- Check the usage of the ProjectTo (Automapper IQueryable exetensions) inside a BaseRepository .
- The idea I think of these projection is to send a limited select of columns to the DB .
- dotnet ef migrations add ExtendModelAddPhotos -o Data/Migrations
- Review this section and try to summarize it .
- Seed method and usage of Automapper
- When we use project to we don't need includes (Some how obvious as automapper 
  will call the DB on lazy loading mode)

Building the user interface
---------------------------------------------
- npm i @kolkov/ngx-gallery
- The best part about this section is the interceptor that will get the request before sending it
  add to it the necessary the token coming from the current user saved inside the accountService 
  and then make sure that all requests will continue to the server with out beautiful token !!! => SO NICE


Updating resources
---------------------------------------------

- In order to use ngx-spinner we will need angular-cdk
- Nice trick for the loading spinners : Using interceptors on the request pipeline
  to show / hide the loading logo => GREAT
- Always there a guard for a certain component to prevent leaving without saving 
- ViewChild => It provides a reference to elements or components in your view .
- HostListener is used to detect any change on the app outside of the angular App (Similar to ref in Vue I beleive)
- Review the usage of HostListener
- Services are singletons
- Some caching is implemented inside the memmber-list component

Photos functionnality
-----------------------------------------------------
- Don't forget : You can always strong type your config variables by creating some
  custom classes .
- The photo service will deal with cloudinary for you
- Review module and summarize 

Reactive forms
-----------------------------------------------------
- Forms on angular can have all the utilities to manage : errors object that react 
  with what's wrong .
- All Form controls derive from ngControl
- constructor(@Self() public ngControl: NgControl)
  => To access the ngControl inside the created new component
- Use use the form builder service => Reactive form

Pagination, Filtering and sorting
---------------------------------------------------------
- Filters in ASP.NET Core allow code to be run before or after specific stages in the request processing pipeline.
- LogUserActivity => Filter used to log the activity after finishing every request (Proposably at the end of the request pipeline)
- Check why the pagination information is on the header of the requests

Likes functionnality
---------------------------------------------------
- dotnet ef migrations add LikesFunctionnality -o Data/Migrations

Messages functionnality
----------------------------------------
- Route resolvers : check the usage 
- MemberDetailedResolver => this will help us to get the memeber before 
  entering the detail component .
- dotnet ef migrations add MessagingFunctionnality -o Data/Migrations


Identity
----------------------------------------
- Identity<int> has already some predefined props , hence the deletion of some props when deriving from 
  Identity<User>
- To be able to use Identity with roles we have to derive the DbContext from : 
        IdentityDbContext<AppUser, AppRole, int, IdentityUserClaim<int>, AppUserRole, IdentityUserLogin<int>, 
        IdentityRoleClaim<int>, IdentityUserToken<int>>
- Join tables in general are done using the config files
- Create the table AppRole : IdentityRole<int>
- Password hash and salt will be managed by Identity
- Managing the user will be done using the UserManager , also authorizing the user 
  and the signing will be done by the SignInManager .
- We will add the roles to the Token description : Check TokenService
- Good to note : The CurrentUser is always stored inside 
  the accountService as an Observable : currentUser$
- atob stands for ASCII to binary e.g.: atob("ZXhhbXBsZSELCg==") == "example!^K" ?? 
- dotnet ef migrations add identityMigration -o Data/migrations
- ef migrations remove => This will remove the last migration
- Update-Database -TargetMigration:"MessagingFunctionnality"
- dotnet ef migrations add SignalRMigration -o Data/migrations
- dotnet tool update --global dotnet-ef --version 5.0.0-preview.8.20407.4

SignalR
----------------------------------------
- Issue with migrations => Simply stop the server


Unit of work and tidying update
----------------------------------------
- ng g c confirm-dialog --skip-test 

Publishing
---------------------------------------
- Check the kerstel server and how it's used to host the angular application
- API/wwwroot is used by kerstel server for static (Everything is bundled on javascript)
- You can use a FallbackController to tell the app what to do in case it does not recognise 
  a route .

- Angular production build => Given for free by the CLI
- ng build --prod 
- The files after the production build are much sameller 
- For Heroku we will use Postgresql
- For Postgresql let us Docker
- hub.docker.com
- Start a postgres image 
    docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres
- => Modified command 
    >docker run --name dev -e POSTGRES_USER=appuser -e POSTGRES_PASSWORD=Za1987 -p 5432:5432 -d postgres:latest
- Postgres master password => Za1987
- Let us switch to postgres
- dotnet ef migrations add PostgresInitial -o Data/migrations

- Heroku
- Using : heroku dotnet buildpack
- Probably you will need to migrate the app to .NET 5
- BuildPack form jinCode for the preview release
  > heroku buildpacks:set https://github.com/jincod/dotnetcore-buildpack#preview
- Setting up heroku : Minute 2.44
- Heroku : Ouss@m@2015
- App name : bookshareappoz
- Use PowerShell
- Herok git => heroku git:remote -a bookshareappoz
- You will need a build pack in order to make your app ready to deploy
   > heroku buildpacks:set https://github.com/jincod/dotnetcore-buildpack#preview 
- On some ways the heroku config variables will check the appsettings.json 
  variables defined and will use them for the rest of the APP .
- Db heroku db string : postgres://rzxunpcjphpbzw:aba58bf49e9e98123f4af130714f86325a3f0dd778463398eaaec7c76ef4dd24@ec2-54-228-209-117.eu-west-1.compute.amazonaws.com:5432/dkaui3q0d1llv